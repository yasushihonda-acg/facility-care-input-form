/**
 * タスク自動生成 (Cloud Scheduler)
 * @see docs/TASK_MANAGEMENT_SPEC.md
 *
 * Cloud Scheduler トリガー（毎日午前6時 Asia/Tokyo）で
 * 品物データに基づくタスクを自動生成
 */

import * as functions from "firebase-functions";
import {getFirestore, FieldValue} from "firebase-admin/firestore";
import {FUNCTIONS_CONFIG} from "../config/sheets";
import type {
  CareItem,
  TaskType,
  TaskPriority,
} from "../types";
import {isScheduledForToday} from "../utils/scheduleUtils";

// Firestoreコレクション名
const TASKS_COLLECTION = "tasks";
const CARE_ITEMS_COLLECTION = "care_items";

/**
 * 日付文字列から日数差を計算
 */
function getDaysUntil(dateString: string): number {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const target = new Date(dateString);
  target.setHours(0, 0, 0, 0);
  const diffTime = target.getTime() - today.getTime();
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
}

/**
 * 日付に日数を加算
 */
function addDays(date: Date, days: number): string {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result.toISOString().split("T")[0];
}

/**
 * 今日の日付をYYYY-MM-DD形式で取得
 */
function getTodayString(): string {
  return new Date().toISOString().split("T")[0];
}

/**
 * タスクID生成
 */
function generateTaskId(): string {
  return `TSK${Date.now()}${Math.random().toString(36).substr(2, 6)}`;
}

/**
 * 既存タスクの重複チェック
 * 同じアイテムID・タスクタイプ・期日のタスクが存在するか確認
 */
async function isDuplicateTask(
  db: FirebaseFirestore.Firestore,
  relatedItemId: string,
  taskType: TaskType,
  dueDate: string
): Promise<boolean> {
  const snapshot = await db
    .collection(TASKS_COLLECTION)
    .where("relatedItemId", "==", relatedItemId)
    .where("taskType", "==", taskType)
    .where("dueDate", "==", dueDate)
    .where("status", "in", ["pending", "in_progress"])
    .limit(1)
    .get();

  return !snapshot.empty;
}

/**
 * タスクを作成して保存
 */
async function createAutoTask(
  db: FirebaseFirestore.Firestore,
  params: {
    residentId: string;
    title: string;
    description: string;
    taskType: TaskType;
    relatedItemId: string;
    dueDate: string;
    priority: TaskPriority;
  }
): Promise<string | null> {
  // 重複チェック
  const isDuplicate = await isDuplicateTask(
    db,
    params.relatedItemId,
    params.taskType,
    params.dueDate
  );

  if (isDuplicate) {
    functions.logger.info("Skipping duplicate task", {
      itemId: params.relatedItemId,
      taskType: params.taskType,
      dueDate: params.dueDate,
    });
    return null;
  }

  const taskId = generateTaskId();
  const taskData = {
    id: taskId,
    residentId: params.residentId,
    title: params.title,
    description: params.description,
    taskType: params.taskType,
    relatedItemId: params.relatedItemId,
    relatedInstructionId: null,
    dueDate: params.dueDate,
    dueTime: null,
    status: "pending",
    priority: params.priority,
    assignee: null,
    completedBy: null,
    completionNote: null,
    notificationSent: false,
    createdBy: "system",
    isAutoGenerated: true,
    createdAt: FieldValue.serverTimestamp(),
    updatedAt: FieldValue.serverTimestamp(),
    completedAt: null,
  };

  await db.collection(TASKS_COLLECTION).doc(taskId).set(taskData);
  return taskId;
}

/**
 * 賞味期限警告タスク生成 (expiration_warning)
 * 賞味期限が3日以内で未提供の品物に対してタスク生成
 */
async function generateExpirationWarnings(
  db: FirebaseFirestore.Firestore
): Promise<number> {
  const today = getTodayString();
  const threeDaysLater = addDays(new Date(), 3);

  functions.logger.info("generateExpirationWarnings", {today, threeDaysLater});

  // 賞味期限が3日以内で未提供の品物を取得
  const snapshot = await db
    .collection(CARE_ITEMS_COLLECTION)
    .where("status", "==", "pending")
    .where("expirationDate", ">=", today)
    .where("expirationDate", "<=", threeDaysLater)
    .get();

  let createdCount = 0;

  for (const doc of snapshot.docs) {
    const item = doc.data() as CareItem;
    const daysUntil = getDaysUntil(item.expirationDate!);

    // 優先度判定: 1日以内は緊急、それ以外は高
    const priority: TaskPriority = daysUntil <= 1 ? "urgent" : "high";

    const taskId = await createAutoTask(db, {
      residentId: item.residentId,
      title: `【期限注意】${item.itemName}の賞味期限が近づいています`,
      description: `賞味期限: ${item.expirationDate}（残り${daysUntil}日）\n` +
        `数量: ${item.remainingQuantity}${item.unit}`,
      taskType: "expiration_warning",
      relatedItemId: item.id,
      dueDate: item.expirationDate!,
      priority,
    });

    if (taskId) {
      createdCount++;
      functions.logger.info("Created expiration warning task", {
        taskId,
        itemId: item.id,
        itemName: item.itemName,
        expirationDate: item.expirationDate,
        daysUntil,
      });
    }
  }

  return createdCount;
}

/**
 * 提供リマインダータスク生成用の説明文を構築
 */
function buildServeReminderDescription(item: CareItem): string {
  // 提供方法のラベルマッピング
  // Phase 28で整理: cooled/blended削除
  const servingMethodLabels: Record<string, string> = {
    as_is: "そのまま",
    cut: "カット",
    peeled: "皮むき",
    heated: "温める",
    other: "その他",
  };

  const servingLabel = servingMethodLabels[item.servingMethod] || item.servingMethod;
  let description = `提供方法: ${servingLabel}`;
  if (item.servingMethodDetail) {
    description += `\n詳細: ${item.servingMethodDetail}`;
  }
  if (item.noteToStaff) {
    description += `\nスタッフへの申し送り: ${item.noteToStaff}`;
  }
  description += `\n数量: ${item.remainingQuantity}${item.unit}`;

  return description;
}

/**
 * 提供リマインダータスク生成 (serve_reminder)
 * 提供予定日が今日の品物に対してタスク生成
 *
 * Phase 36: 構造化スケジュール（servingSchedule）対応
 * - Phase 1: plannedServeDateが今日の品物（後方互換）
 * - Phase 2: servingScheduleを持つ品物をサーバー側で判定
 */
async function generateServeReminders(
  db: FirebaseFirestore.Firestore
): Promise<number> {
  const today = getTodayString();

  functions.logger.info("generateServeReminders", {today});

  let createdCount = 0;
  const processedItemIds = new Set<string>();

  // Phase 1: plannedServeDateが今日の品物（後方互換）
  const legacySnapshot = await db
    .collection(CARE_ITEMS_COLLECTION)
    .where("status", "==", "pending")
    .where("plannedServeDate", "==", today)
    .get();

  functions.logger.info("Phase 1: plannedServeDate query", {
    count: legacySnapshot.size,
  });

  for (const doc of legacySnapshot.docs) {
    const item = doc.data() as CareItem;
    processedItemIds.add(item.id);

    const description = buildServeReminderDescription(item);
    const taskId = await createAutoTask(db, {
      residentId: item.residentId,
      title: `【提供予定】${item.itemName}を提供してください`,
      description,
      taskType: "serve_reminder",
      relatedItemId: item.id,
      dueDate: today,
      priority: "medium",
    });

    if (taskId) {
      createdCount++;
      functions.logger.info("Created serve reminder task (legacy)", {
        taskId,
        itemId: item.id,
        itemName: item.itemName,
        plannedServeDate: item.plannedServeDate,
      });
    }
  }

  // Phase 2: 構造化スケジュールを持つ品物
  // Firestoreでは servingSchedule != null のクエリができないため、
  // status == pending の全品物を取得してサーバー側でフィルタリング
  const allPendingSnapshot = await db
    .collection(CARE_ITEMS_COLLECTION)
    .where("status", "==", "pending")
    .get();

  functions.logger.info("Phase 2: all pending items query", {
    count: allPendingSnapshot.size,
  });

  let scheduledCount = 0;
  for (const doc of allPendingSnapshot.docs) {
    const item = doc.data() as CareItem;

    // Phase 1で既に処理済みならスキップ
    if (processedItemIds.has(item.id)) continue;

    // servingScheduleがない場合はスキップ
    if (!item.servingSchedule) continue;

    // スケジュール判定（開始日チェック含む）
    if (isScheduledForToday(item.servingSchedule)) {
      scheduledCount++;
      const description = buildServeReminderDescription(item);
      const taskId = await createAutoTask(db, {
        residentId: item.residentId,
        title: `【提供予定】${item.itemName}を提供してください`,
        description,
        taskType: "serve_reminder",
        relatedItemId: item.id,
        dueDate: today,
        priority: "medium",
      });

      if (taskId) {
        createdCount++;
        functions.logger.info("Created serve reminder task (scheduled)", {
          taskId,
          itemId: item.id,
          itemName: item.itemName,
          scheduleType: item.servingSchedule.type,
          startDate: item.servingSchedule.startDate,
        });
      }
    }
  }

  functions.logger.info("generateServeReminders completed", {
    legacyCount: legacySnapshot.size,
    scheduledMatches: scheduledCount,
    totalCreated: createdCount,
  });

  return createdCount;
}

/**
 * 毎日のタスク自動生成 (Cloud Scheduler)
 * スケジュール: 毎日午前6時 (Asia/Tokyo)
 */
export const generateDailyTasks = functions
  .region(FUNCTIONS_CONFIG.REGION)
  .runWith({
    timeoutSeconds: 120,
    memory: "256MB",
    serviceAccount: FUNCTIONS_CONFIG.SERVICE_ACCOUNT,
  })
  .pubsub.schedule("0 6 * * *")
  .timeZone("Asia/Tokyo")
  .onRun(async (context) => {
    functions.logger.info("generateDailyTasks started", {
      eventId: context.eventId,
      timestamp: context.timestamp,
    });

    const db = getFirestore();
    const results = {
      expirationWarnings: 0,
      serveReminders: 0,
      errors: [] as string[],
    };

    try {
      // 賞味期限警告タスク生成
      results.expirationWarnings = await generateExpirationWarnings(db);
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : "Unknown error";
      functions.logger.error("generateExpirationWarnings error", {error: errorMsg});
      results.errors.push(`expirationWarnings: ${errorMsg}`);
    }

    try {
      // 提供リマインダータスク生成
      results.serveReminders = await generateServeReminders(db);
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : "Unknown error";
      functions.logger.error("generateServeReminders error", {error: errorMsg});
      results.errors.push(`serveReminders: ${errorMsg}`);
    }

    functions.logger.info("generateDailyTasks completed", {
      results,
      totalCreated: results.expirationWarnings + results.serveReminders,
    });

    return results;
  });

/**
 * 手動タスク生成エンドポイント (テスト・デバッグ用)
 * POST /triggerTaskGeneration
 */
export const triggerTaskGeneration = functions
  .region(FUNCTIONS_CONFIG.REGION)
  .runWith({
    timeoutSeconds: 120,
    memory: "256MB",
    serviceAccount: FUNCTIONS_CONFIG.SERVICE_ACCOUNT,
  })
  .https.onRequest(async (req, res) => {
    // CORS設定
    res.set("Access-Control-Allow-Origin", "*");
    res.set("Access-Control-Allow-Methods", "POST, OPTIONS");
    res.set("Access-Control-Allow-Headers", "Content-Type");

    if (req.method === "OPTIONS") {
      res.status(204).send("");
      return;
    }

    if (req.method !== "POST") {
      res.status(405).json({
        success: false,
        error: {code: "METHOD_NOT_ALLOWED", message: "Only POST allowed"},
      });
      return;
    }

    const timestamp = new Date().toISOString();

    // admin パラメータチェック（本番では認証を追加）
    if (req.query.admin !== "true") {
      res.status(403).json({
        success: false,
        error: {code: "FORBIDDEN", message: "Admin access required"},
        timestamp,
      });
      return;
    }

    functions.logger.info("triggerTaskGeneration manual trigger");

    const db = getFirestore();
    const results = {
      expirationWarnings: 0,
      serveReminders: 0,
      errors: [] as string[],
    };

    try {
      results.expirationWarnings = await generateExpirationWarnings(db);
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : "Unknown error";
      functions.logger.error("generateExpirationWarnings error", {error: errorMsg});
      results.errors.push(`expirationWarnings: ${errorMsg}`);
    }

    try {
      results.serveReminders = await generateServeReminders(db);
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : "Unknown error";
      functions.logger.error("generateServeReminders error", {error: errorMsg});
      results.errors.push(`serveReminders: ${errorMsg}`);
    }

    functions.logger.info("triggerTaskGeneration completed", {results});

    res.status(200).json({
      success: results.errors.length === 0,
      data: {
        expirationWarningsCreated: results.expirationWarnings,
        serveRemindersCreated: results.serveReminders,
        totalCreated: results.expirationWarnings + results.serveReminders,
        errors: results.errors,
      },
      timestamp,
    });
  });
