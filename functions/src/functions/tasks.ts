/**
 * タスク管理 API
 * @see docs/TASK_MANAGEMENT_SPEC.md
 */

import * as functions from "firebase-functions";
import {Request, Response} from "express";
import {getFirestore, FieldValue} from "firebase-admin/firestore";
import {FUNCTIONS_CONFIG} from "../config/sheets";
import type {
  ApiResponse,
  Task,
  TaskStatus,
  TaskPriority,
  TaskType,
  CreateTaskRequest,
  CreateTaskResponse,
  GetTasksRequest,
  GetTasksResponse,
  TaskCounts,
  UpdateTaskRequest,
  UpdateTaskResponse,
} from "../types";

// Firestoreコレクション名
const TASKS_COLLECTION = "tasks";

// 優先度の順序マップ（ソート用）
const PRIORITY_ORDER: Record<TaskPriority, number> = {
  urgent: 0,
  high: 1,
  medium: 2,
  low: 3,
};

/**
 * CORS設定を適用
 */
function setCorsHeaders(res: Response): void {
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type");
}

/**
 * タスク作成 (createTask)
 * POST /createTask
 */
async function createTaskHandler(req: Request, res: Response): Promise<void> {
  setCorsHeaders(res);

  if (req.method === "OPTIONS") {
    res.status(204).send("");
    return;
  }

  if (req.method !== "POST") {
    res.status(405).json({success: false, error: {code: "METHOD_NOT_ALLOWED", message: "Only POST allowed"}});
    return;
  }

  const timestamp = new Date().toISOString();
  const db = getFirestore();

  try {
    const body = req.body as CreateTaskRequest;
    const {residentId, title, dueDate, priority} = body;

    // バリデーション
    if (!residentId || !title || !dueDate || !priority) {
      const response: ApiResponse<null> = {
        success: false,
        error: {
          code: "INVALID_REQUEST",
          message: "Required fields: residentId, title, dueDate, priority",
        },
        timestamp,
      };
      res.status(400).json(response);
      return;
    }

    // タスクID生成
    const taskId = `TSK${Date.now()}${Math.random().toString(36).substr(2, 6)}`;

    // タスクデータ作成
    const taskData = {
      id: taskId,
      residentId,
      title,
      description: body.description || null,
      taskType: body.taskType || "custom",
      relatedItemId: body.relatedItemId || null,
      relatedInstructionId: body.relatedInstructionId || null,
      dueDate,
      dueTime: body.dueTime || null,
      status: "pending" as TaskStatus,
      priority,
      assignee: body.assignee || null,
      completedBy: null,
      completionNote: null,
      notificationSent: false,
      createdBy: body.createdBy || null,
      isAutoGenerated: false,
      createdAt: FieldValue.serverTimestamp(),
      updatedAt: FieldValue.serverTimestamp(),
      completedAt: null,
    };

    // Firestoreに保存
    await db.collection(TASKS_COLLECTION).doc(taskId).set(taskData);

    functions.logger.info("createTask success", {taskId});

    const response: ApiResponse<CreateTaskResponse> = {
      success: true,
      data: {
        taskId,
        createdAt: timestamp,
      },
      timestamp,
    };
    res.status(201).json(response);
  } catch (error) {
    functions.logger.error("createTask error", error);
    const response: ApiResponse<null> = {
      success: false,
      error: {
        code: "INTERNAL_ERROR",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      timestamp,
    };
    res.status(500).json(response);
  }
}

export const createTask = functions
  .region(FUNCTIONS_CONFIG.REGION)
  .runWith({
    timeoutSeconds: 60,
    memory: "256MB",
    serviceAccount: FUNCTIONS_CONFIG.SERVICE_ACCOUNT,
  })
  .https.onRequest(createTaskHandler);

/**
 * タスク一覧取得 (getTasks)
 * GET /getTasks
 */
async function getTasksHandler(req: Request, res: Response): Promise<void> {
  setCorsHeaders(res);

  if (req.method === "OPTIONS") {
    res.status(204).send("");
    return;
  }

  if (req.method !== "GET") {
    res.status(405).json({success: false, error: {code: "METHOD_NOT_ALLOWED", message: "Only GET allowed"}});
    return;
  }

  const timestamp = new Date().toISOString();
  const db = getFirestore();

  try {
    const params = req.query as unknown as GetTasksRequest;
    const limitNum = Math.min(Number(params.limit) || 50, 100);
    const offset = Number(params.offset) || 0;

    // クエリ構築
    let query: FirebaseFirestore.Query = db.collection(TASKS_COLLECTION);

    // フィルタ適用
    if (params.residentId) {
      query = query.where("residentId", "==", params.residentId);
    }

    if (params.status) {
      const statusArray = Array.isArray(params.status) ? params.status : [params.status];
      if (statusArray.length === 1) {
        query = query.where("status", "==", statusArray[0]);
      } else if (statusArray.length > 1) {
        query = query.where("status", "in", statusArray);
      }
    }

    if (params.taskType) {
      query = query.where("taskType", "==", params.taskType);
    }

    if (params.priority) {
      query = query.where("priority", "==", params.priority);
    }

    if (params.dueDate) {
      query = query.where("dueDate", "==", params.dueDate);
    } else {
      if (params.dueDateStart) {
        query = query.where("dueDate", ">=", params.dueDateStart);
      }
      if (params.dueDateEnd) {
        query = query.where("dueDate", "<=", params.dueDateEnd);
      }
    }

    // ソート
    const sortBy = params.sortBy || "dueDate";
    const sortOrder = params.sortOrder || "asc";

    if (sortBy === "dueDate") {
      query = query.orderBy("dueDate", sortOrder);
    } else if (sortBy === "createdAt") {
      query = query.orderBy("createdAt", sortOrder);
    }
    // priority ソートはクライアント側で行う（Firestoreの制約）

    // 全件取得（件数カウント用）
    const allSnapshot = await query.get();
    const total = allSnapshot.size;

    // ページネーション適用
    const paginatedQuery = query.offset(offset).limit(limitNum);
    const snapshot = await paginatedQuery.get();

    // タスクデータ変換
    let tasks: Task[] = snapshot.docs.map((doc) => {
      const data = doc.data();
      return {
        id: doc.id,
        residentId: data.residentId,
        title: data.title,
        description: data.description || undefined,
        taskType: data.taskType as TaskType,
        relatedItemId: data.relatedItemId || undefined,
        relatedInstructionId: data.relatedInstructionId || undefined,
        dueDate: data.dueDate,
        dueTime: data.dueTime || undefined,
        status: data.status as TaskStatus,
        priority: data.priority as TaskPriority,
        assignee: data.assignee || undefined,
        completedBy: data.completedBy || undefined,
        completionNote: data.completionNote || undefined,
        notificationSent: data.notificationSent || false,
        createdBy: data.createdBy || undefined,
        isAutoGenerated: data.isAutoGenerated || false,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt,
        completedAt: data.completedAt || undefined,
      };
    });

    // 優先度ソートが指定されている場合はクライアント側でソート
    if (sortBy === "priority") {
      tasks = tasks.sort((a, b) => {
        const orderA = PRIORITY_ORDER[a.priority] ?? 99;
        const orderB = PRIORITY_ORDER[b.priority] ?? 99;
        return sortOrder === "asc" ? orderA - orderB : orderB - orderA;
      });
    }

    // タスク件数を計算
    const today = new Date().toISOString().split("T")[0];
    const counts: TaskCounts = {
      pending: 0,
      inProgress: 0,
      completed: 0,
      overdue: 0,
    };

    allSnapshot.docs.forEach((doc) => {
      const data = doc.data();
      const status = data.status as TaskStatus;
      const dueDate = data.dueDate as string;

      if (status === "pending") {
        counts.pending++;
        if (dueDate < today) {
          counts.overdue++;
        }
      } else if (status === "in_progress") {
        counts.inProgress++;
        if (dueDate < today) {
          counts.overdue++;
        }
      } else if (status === "completed") {
        counts.completed++;
      }
    });

    functions.logger.info("getTasks success", {total, returned: tasks.length});

    const response: ApiResponse<GetTasksResponse> = {
      success: true,
      data: {
        tasks,
        total,
        counts,
      },
      timestamp,
    };
    res.status(200).json(response);
  } catch (error) {
    functions.logger.error("getTasks error", error);
    const response: ApiResponse<null> = {
      success: false,
      error: {
        code: "INTERNAL_ERROR",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      timestamp,
    };
    res.status(500).json(response);
  }
}

export const getTasks = functions
  .region(FUNCTIONS_CONFIG.REGION)
  .runWith({
    timeoutSeconds: 60,
    memory: "256MB",
    serviceAccount: FUNCTIONS_CONFIG.SERVICE_ACCOUNT,
  })
  .https.onRequest(getTasksHandler);

/**
 * タスク更新 (updateTask)
 * PUT /updateTask
 */
async function updateTaskHandler(req: Request, res: Response): Promise<void> {
  setCorsHeaders(res);

  if (req.method === "OPTIONS") {
    res.status(204).send("");
    return;
  }

  if (req.method !== "PUT") {
    res.status(405).json({success: false, error: {code: "METHOD_NOT_ALLOWED", message: "Only PUT allowed"}});
    return;
  }

  const timestamp = new Date().toISOString();
  const db = getFirestore();

  try {
    const body = req.body as UpdateTaskRequest;
    const {taskId, updates, completedBy} = body;

    // バリデーション
    if (!taskId) {
      const response: ApiResponse<null> = {
        success: false,
        error: {
          code: "INVALID_REQUEST",
          message: "taskId is required",
        },
        timestamp,
      };
      res.status(400).json(response);
      return;
    }

    if (!updates || Object.keys(updates).length === 0) {
      const response: ApiResponse<null> = {
        success: false,
        error: {
          code: "INVALID_REQUEST",
          message: "updates object is required",
        },
        timestamp,
      };
      res.status(400).json(response);
      return;
    }

    // タスク存在確認
    const docRef = db.collection(TASKS_COLLECTION).doc(taskId);
    const doc = await docRef.get();

    if (!doc.exists) {
      const response: ApiResponse<null> = {
        success: false,
        error: {
          code: "NOT_FOUND",
          message: `Task ${taskId} not found`,
        },
        timestamp,
      };
      res.status(404).json(response);
      return;
    }

    // 更新データ構築
    const updateData: Record<string, unknown> = {
      ...updates,
      updatedAt: FieldValue.serverTimestamp(),
    };

    // 完了処理
    if (updates.status === "completed") {
      updateData.completedAt = FieldValue.serverTimestamp();
      if (completedBy) {
        updateData.completedBy = completedBy;
      }
    }

    await docRef.update(updateData);

    functions.logger.info("updateTask success", {taskId, status: updates.status});

    const response: ApiResponse<UpdateTaskResponse> = {
      success: true,
      data: {
        taskId,
        status: updates.status || (doc.data()?.status as TaskStatus),
        updatedAt: timestamp,
      },
      timestamp,
    };
    res.status(200).json(response);
  } catch (error) {
    functions.logger.error("updateTask error", error);
    const response: ApiResponse<null> = {
      success: false,
      error: {
        code: "INTERNAL_ERROR",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      timestamp,
    };
    res.status(500).json(response);
  }
}

export const updateTask = functions
  .region(FUNCTIONS_CONFIG.REGION)
  .runWith({
    timeoutSeconds: 60,
    memory: "256MB",
    serviceAccount: FUNCTIONS_CONFIG.SERVICE_ACCOUNT,
  })
  .https.onRequest(updateTaskHandler);

/**
 * タスク削除 (deleteTask)
 * DELETE /deleteTask
 */
async function deleteTaskHandler(req: Request, res: Response): Promise<void> {
  setCorsHeaders(res);

  if (req.method === "OPTIONS") {
    res.status(204).send("");
    return;
  }

  if (req.method !== "DELETE") {
    res.status(405).json({success: false, error: {code: "METHOD_NOT_ALLOWED", message: "Only DELETE allowed"}});
    return;
  }

  const timestamp = new Date().toISOString();
  const db = getFirestore();

  try {
    const taskId = req.query.taskId as string;

    if (!taskId) {
      const response: ApiResponse<null> = {
        success: false,
        error: {
          code: "INVALID_REQUEST",
          message: "taskId query parameter is required",
        },
        timestamp,
      };
      res.status(400).json(response);
      return;
    }

    // タスク存在確認
    const docRef = db.collection(TASKS_COLLECTION).doc(taskId);
    const doc = await docRef.get();

    if (!doc.exists) {
      const response: ApiResponse<null> = {
        success: false,
        error: {
          code: "NOT_FOUND",
          message: `Task ${taskId} not found`,
        },
        timestamp,
      };
      res.status(404).json(response);
      return;
    }

    await docRef.delete();

    functions.logger.info("deleteTask success", {taskId});

    const response: ApiResponse<null> = {
      success: true,
      data: null,
      timestamp,
    };
    res.status(200).json(response);
  } catch (error) {
    functions.logger.error("deleteTask error", error);
    const response: ApiResponse<null> = {
      success: false,
      error: {
        code: "INTERNAL_ERROR",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      timestamp,
    };
    res.status(500).json(response);
  }
}

export const deleteTask = functions
  .region(FUNCTIONS_CONFIG.REGION)
  .runWith({
    timeoutSeconds: 60,
    memory: "256MB",
    serviceAccount: FUNCTIONS_CONFIG.SERVICE_ACCOUNT,
  })
  .https.onRequest(deleteTaskHandler);
